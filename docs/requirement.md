### PPT 生成 Agent

#### 实验目的

PPT 创作往往耗时费力。一个典型的学术报告 PPT 可能包含数十页幻灯片，每一页都需要精心设计布局、提炼要点、选配图表。传统的 PPT 制作工具虽然功能强大，但对 AI Agent 而言却是一个挑战——这些图形界面驱动的工具需要复杂的鼠标操作、拖拽定位、样式调整，难以通过程序化的方式精确控制。

#### 背景知识

**Proposer-Reviewer 范式**：这是一种多 Agent 协作模式，通过分工实现质量提升。Proposer(提议者)负责生成初始方案，Reviewer(审查者)负责评估方案质量并提出改进建议。这种分工带来两个核心优势：一是专业化——Proposer 专注于创造性生成，Reviewer 专注于批判性评估，各司其职;二是上下文隔离——Reviewer 只需分析当前版本，避免在单一上下文中累积所有历史版本导致的上下文膨胀问题。

在 PPT 生成场景中，Editor Agent 扮演 Proposer 角色，Critic Agent 扮演 Reviewer 角色。Critic 通过渲染 PPT 为图片并使用 Vision LLM 进行多维度评估(内容密度、可读性、布局合理性、视觉美感)，生成结构化的改进建议。Editor 根据建议调整代码，形成迭代循环。

**Slidev 框架**：Slidev 是一个专为开发者设计的演示文稿工具，用 Markdown 和 HTML 定义内容，用主题和 CSS 控制样式。这种设计将 PPT 创作转化为代码生成问题，非常适合 Agent 操作——Agent 只需生成 Markdown/HTML 代码，无需理解复杂的 GUI 软件。

#### 实验内容描述

PPT 创作往往耗时费力。一个典型的学术报告 PPT 可能包含数十页幻灯片，每一页都需要精心设计布局、提炼要点、选配图表。传统的 PPT 制作工具虽然功能强大，但对 AI Agent 而言却是一个挑战——这些图形界面驱动的工具需要复杂的鼠标操作、拖拽定位、样式调整，难以通过程序化的方式精确控制。

对于 Agent 而言，如果将 PPT 的创作问题重新框定为一个代码生成问题，就能极大简化其复杂度。现代的 PPT 框架（如 Slidev）采用了一种优雅的设计哲学：用 Markdown 和 HTML 来定义演示内容。Slidev 是一个专为开发者设计的演示文稿工具，它将幻灯片的内容与样式分离——内容用简洁的 Markdown 语法编写，样式通过主题和 CSS 控制，交互和动画可以用 Vue 组件实现。

这意味着，创建一页幻灯片只需要编写一段简洁的标记语言——用 Markdown 表达文字内容和结构，用 HTML 嵌入图片和自定义元素，框架会自动处理渲染、布局、动画等细节。对于掌握了代码生成能力的 Agent，这种模式极其友好：它不需要理解复杂的 GUI 软件，只需要理解 Markdown 和 HTML 这两种结构化语言，这正是大语言模型最擅长的任务之一。

然而，仅仅能生成 PPT 代码还不够。**Editor Agent 编写完代码后，并不知道代码的实际渲染效果**——内容是否太挤、文字是否溢出边界、图片尺寸是否合适、字体大小是否合理、颜色搭配是否协调，这些视觉问题只有通过实际渲染才能发现。这与人类创作 PPT 的过程完全一致：我们通过 GUI 看到操作的实际效果，然后根据视觉反馈进一步调整内容。一个优秀的演示文稿不仅需要内容正确，更需要视觉呈现清晰、专业。

因此，质量保证需要引入 **Render-Critique 机制**，这正是 Proposer-Reviewer 范式在 PPT 生成场景中的具体应用。系统被设计为两个协作的 Agent：**Editor Agent（Proposer）** 和 **Critic Agent（Reviewer）**。Editor Agent 负责根据用户提供的内容（如论文摘要、会议讲稿、产品介绍）生成 Slidev 格式的幻灯片代码。它需要理解内容的逻辑结构，将其分解为合理的页面，为每一页选择合适的布局模式，用 Markdown 语法组织文字，用 HTML 嵌入必要的媒体元素。

Critic Agent 则扮演着视觉质量审查者的角色。它的工作流程包含几个关键步骤。首先是**渲染执行**：Critic 使用 Slidev 的命令行工具，将 Editor 生成的代码渲染为 PDF 或一系列 PNG 图片。每一页幻灯片都被转换为高分辨率的图像，这些图像成为视觉分析的输入。其次是**多维度评估**：Critic 利用 Vision LLM 的多模态理解能力，对每一页渲染结果进行分析。评估维度包括：内容密度（页面是否过于拥挤或过于空旷）、可读性（字体大小是否合适，文字与背景对比度是否足够）、布局合理性（元素排列是否整齐，重要信息是否突出）、视觉美感（颜色搭配是否协调，整体风格是否统一）。

基于这些分析，Critic 生成**结构化的改进建议**。这些建议不是模糊的"这页不好看"，而是具体的、可执行的指导，例如："第 3 页：内容过多，建议将下半部分的三个要点拆分到新的一页"、"第 7 页：代码块字体过小，建议减少代码行数或增大字体到 14pt"、"第 12 页：图片与文字重叠，建议将图片移动到右侧，文字左对齐"。这些建议被格式化为结构化的反馈对象，包含页码、问题类型、严重程度、具体建议等字段。

Editor Agent 接收到 Critic 的反馈后，并非盲目地应用所有建议，而是理解每条建议的意图，在保持内容完整性的前提下进行调整。如果建议是"内容过多需要拆分"，Editor 需要识别自然的分割点，确保拆分后的逻辑依然连贯；如果建议是"字体过小"，Editor 需要在增大字体的同时调整布局，避免文字溢出。修改完成后，新版本的代码再次提交给 Critic 进行审查，形成迭代循环。

这个循环可能经历多轮，直到 Critic 认为所有页面的视觉效果都达到了可接受的标准，或者达到预设的最大迭代次数（例如 5 轮）。每一轮迭代都使得 PPT 的质量逐步提升，从初始的"功能可用"向"视觉专业"演进。

需要注意的是，也可以使用单个 Agent 反复执行 render-修改循环，每次都将渲染图片输入 Vision LLM 进行自我审查。但这种方式容易导致 **context 快速膨胀**——一个完整的 PPT 包含数十页，每页图片占用大量 token（一张 1080p 的截图可能消耗数千个 token），多轮迭代会使上下文迅速超出限制。更严重的是，当上下文中累积了大量历史版本的渲染图片时，模型可能会混淆不同版本之间的差异，甚至产生幻觉认为某个已经修复的问题仍然存在。

Editor-Critic 分工模式通过让 Critic 聚焦于当前版本的评审，避免了在单一上下文中累积所有历史渲染图片的问题。每次迭代时，Critic 只需要分析最新版本的渲染结果，它的上下文相对干净。Editor 的上下文中虽然会累积 Critic 的历史反馈，但这些反馈是结构化的文本，比图片占用的 token 少得多，且更易于模型理解和推理。这种设计在保证审查质量的同时，实现了更高效的上下文利用。

**实验要求**：
1. 准备一个内容丰富的输入（如一篇学术论文的扩展摘要，包含背景、方法、实验、结论等部分，约 2000-3000 字）
2. 实现 Editor Agent，使其能够将输入内容转换为 Slidev 格式的幻灯片，包含标题页、目录页、内容页、结论页等
3. 实现 Critic Agent，使其能够调用 Slidev 的渲染工具，将代码转换为图片，并使用 Vision LLM 进行视觉质量评估
4. 实现迭代循环机制，让 Editor 根据 Critic 的反馈进行修改，直到质量达标或达到最大迭代次数
5. 记录每轮迭代的反馈内容和修改动作，展示 PPT 质量的逐步提升过程
6. 对比单 Agent 自我审查模式和双 Agent 协作模式在上下文消耗、生成质量、迭代效率等方面的差异

#### 期望验收结果

- 展示完整的迭代过程：记录每轮 Critic Agent 的视觉评估反馈(如"第3页内容过多"、"第7页字体过小")和 Editor Agent 的相应调整
- 对比单 Agent 自我审查模式和双 Agent 协作模式：分析两种方式在上下文消耗、生成质量、迭代效率等方面的差异，验证分工模式在避免上下文膨胀方面的优势
- 演示至少3轮的 Render-Critique 循环，展示 PPT 质量如何从初始的"功能可用"逐步提升到"视觉专业"
- 最终生成的 PPT 应符合专业标准：内容密度适中、布局合理、字体清晰、视觉协调
